import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';

const NetworkTopology3D = () => {
  const containerRef = useRef(null);
  const [animationSpeed, setAnimationSpeed] = useState(1);
  const [showLabels, setShowLabels] = useState(true);
  const sceneRef = useRef(null);
  const rendererRef = useRef(null);
  const cameraRef = useRef(null);

  useEffect(() => {
    if (!containerRef.current) return;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    sceneRef.current = scene;

    // Camera
    const camera = new THREE.PerspectiveCamera(
      60,
      containerRef.current.clientWidth / containerRef.current.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, 15, 25);
    camera.lookAt(0, 0, 0);
    cameraRef.current = camera;

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // Grid
    const gridHelper = new THREE.GridHelper(40, 40, 0xcccccc, 0xe0e0e0);
    scene.add(gridHelper);

    // Router positions
    const positions = {
      N9K1: { x: -8, y: 2, z: 5 },
      N9K2: { x: 8, y: 2, z: 5 },
      N9K3: { x: -12, y: 0, z: -3 },
      N9K4: { x: 12, y: 0, z: -3 },
      Server1: { x: -12, y: 0, z: -10 },
      Server2: { x: 12, y: 0, z: -10 }
    };

    // Create routers
    const routers = {};
    const createRouter = (name, position, color) => {
      const group = new THREE.Group();
      
      // Main body
      const geometry = new THREE.BoxGeometry(1.5, 2, 1.5);
      const material = new THREE.MeshPhongMaterial({ 
        color: color,
        specular: 0x444444,
        shininess: 30
      });
      const mesh = new THREE.Mesh(geometry, material);
      group.add(mesh);

      // Front panel
      const panelGeo = new THREE.BoxGeometry(1.6, 0.3, 0.1);
      const panelMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
      for (let i = 0; i < 4; i++) {
        const panel = new THREE.Mesh(panelGeo, panelMat);
        panel.position.set(0, -0.7 + i * 0.5, 0.76);
        group.add(panel);
      }

      // LED indicators
      for (let i = 0; i < 6; i++) {
        const ledGeo = new THREE.SphereGeometry(0.05);
        const ledMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const led = new THREE.Mesh(ledGeo, ledMat);
        led.position.set(-0.6 + i * 0.25, 0.8, 0.77);
        group.add(led);
        
        // Animate LEDs
        led.userData.animation = (time) => {
          const brightness = Math.sin(time * 3 + i * 0.5) * 0.3 + 0.7;
          ledMat.color.setHSL(0.33, 1, brightness);
        };
      }

      group.position.set(position.x, position.y, position.z);
      scene.add(group);
      routers[name] = group;
      return group;
    };

    // Create servers
    const createServer = (name, position) => {
      const group = new THREE.Group();
      
      const geometry = new THREE.BoxGeometry(1, 1.5, 1);
      const material = new THREE.MeshPhongMaterial({ 
        color: name === 'Server1' ? 0x4a90e2 : 0xe24a4a,
        specular: 0x666666,
        shininess: 40
      });
      const mesh = new THREE.Mesh(geometry, material);
      group.add(mesh);

      // Server icon
      const iconGeo = new THREE.PlaneGeometry(0.6, 0.6);
      const iconMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const icon = new THREE.Mesh(iconGeo, iconMat);
      icon.position.set(0, 0, 0.51);
      group.add(icon);

      group.position.set(position.x, position.y, position.z);
      scene.add(group);
      routers[name] = group;
      return group;
    };

    createRouter('N9K1', positions.N9K1, 0x2196f3);
    createRouter('N9K2', positions.N9K2, 0x2196f3);
    createRouter('N9K3', positions.N9K3, 0x4caf50);
    createRouter('N9K4', positions.N9K4, 0x4caf50);
    createServer('Server1', positions.Server1);
    createServer('Server2', positions.Server2);

    // Connection lines
    const connections = [
      { from: 'N9K1', to: 'N9K3', label: '1.1.13.0/30' },
      { from: 'N9K1', to: 'N9K4', label: '1.1.14.0/30' },
      { from: 'N9K2', to: 'N9K3', label: '1.1.23.0/30' },
      { from: 'N9K2', to: 'N9K4', label: '1.1.24.0/30' },
      { from: 'N9K3', to: 'Server1' },
      { from: 'N9K4', to: 'Server2' }
    ];

    const dataPackets = [];
    
    connections.forEach((conn, index) => {
      const fromPos = positions[conn.from];
      const toPos = positions[conn.to];
      
      // Create curved line
      const curve = new THREE.QuadraticBezierCurve3(
        new THREE.Vector3(fromPos.x, fromPos.y, fromPos.z),
        new THREE.Vector3(
          (fromPos.x + toPos.x) / 2,
          Math.max(fromPos.y, toPos.y) + 2,
          (fromPos.z + toPos.z) / 2
        ),
        new THREE.Vector3(toPos.x, toPos.y, toPos.z)
      );

      const points = curve.getPoints(50);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ 
        color: 0x0066cc,
        linewidth: 2
      });
      const line = new THREE.Line(geometry, material);
      scene.add(line);

      // Data packets
      for (let i = 0; i < 2; i++) {
        const packetGeo = new THREE.SphereGeometry(0.15);
        const packetMat = new THREE.MeshBasicMaterial({ 
          color: 0xffff00,
          transparent: true,
          opacity: 0.8
        });
        const packet = new THREE.Mesh(packetGeo, packetMat);
        packet.userData = {
          curve: curve,
          progress: i * 0.5,
          speed: 0.3 + Math.random() * 0.2,
          index: index
        };
        scene.add(packet);
        dataPackets.push(packet);
      }
    });

    // Labels
    const labels = [];
    const createLabel = (text, position) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 256;
      canvas.height = 64;
      
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'black';
      ctx.font = 'bold 24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(text, 128, 40);
      
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture });
      const sprite = new THREE.Sprite(material);
      sprite.position.set(position.x, position.y + 2, position.z);
      sprite.scale.set(3, 0.75, 1);
      scene.add(sprite);
      labels.push(sprite);
      return sprite;
    };

    Object.keys(positions).forEach(name => {
      createLabel(name, positions[name]);
    });

    // Animation
    let time = 0;
    const animate = () => {
      requestAnimationFrame(animate);
      time += 0.016 * animationSpeed;

      // Rotate camera
      camera.position.x = Math.sin(time * 0.1) * 25;
      camera.position.z = Math.cos(time * 0.1) * 25;
      camera.lookAt(0, 0, 0);

      // Animate LEDs
      Object.values(routers).forEach(router => {
        router.children.forEach(child => {
          if (child.userData.animation) {
            child.userData.animation(time);
          }
        });
      });

      // Animate data packets
      dataPackets.forEach(packet => {
        packet.userData.progress += 0.01 * packet.userData.speed * animationSpeed;
        if (packet.userData.progress > 1) {
          packet.userData.progress = 0;
        }
        
        const point = packet.userData.curve.getPoint(packet.userData.progress);
        packet.position.copy(point);
        
        // Pulse effect
        const scale = 1 + Math.sin(time * 5 + packet.userData.index) * 0.3;
        packet.scale.set(scale, scale, scale);
      });

      // Toggle label visibility
      labels.forEach(label => {
        label.visible = showLabels;
      });

      renderer.render(scene, camera);
    };

    animate();

    // Handle resize
    const handleResize = () => {
      if (!containerRef.current) return;
      camera.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      if (containerRef.current && renderer.domElement) {
        containerRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [animationSpeed, showLabels]);

  const captureFrame = () => {
    if (rendererRef.current) {
      const dataUrl = rendererRef.current.domElement.toDataURL('image/png');
      const link = document.createElement('a');
      link.download = `network-frame-${Date.now()}.png`;
      link.href = dataUrl;
      link.click();
    }
  };

  return (
    <div className="w-full h-screen bg-gray-100 flex flex-col">
      <div className="bg-white shadow-md p-4 flex items-center justify-between">
        <h1 className="text-2xl font-bold text-gray-800">3D ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÜ†Ìè¥Î°úÏßÄ</h1>
        <div className="flex gap-4 items-center">
          <div className="flex items-center gap-2">
            <label className="text-sm font-medium">ÏÜçÎèÑ:</label>
            <input
              type="range"
              min="0.1"
              max="3"
              step="0.1"
              value={animationSpeed}
              onChange={(e) => setAnimationSpeed(parseFloat(e.target.value))}
              className="w-32"
            />
            <span className="text-sm w-12">{animationSpeed.toFixed(1)}x</span>
          </div>
          <label className="flex items-center gap-2">
            <input
              type="checkbox"
              checked={showLabels}
              onChange={(e) => setShowLabels(e.target.checked)}
              className="w-4 h-4"
            />
            <span className="text-sm font-medium">ÎùºÎ≤® ÌëúÏãú</span>
          </label>
          <button
            onClick={captureFrame}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
          >
            üì∏ Ï∫°Ï≤ò
          </button>
        </div>
      </div>
      <div ref={containerRef} className="flex-1" />
      <div className="bg-white border-t p-4">
        <div className="grid grid-cols-3 gap-4 text-sm">
          <div>
            <strong>VNI:</strong> 10011
          </div>
          <div>
            <strong>Underlay:</strong> OSPF
          </div>
          <div>
            <strong>Loopback:</strong> /32
          </div>
          <div>
            <strong>Mcast Group:</strong> 225.0.0.10
          </div>
          <div>
            <strong>Mcast RP:</strong> 10.1.1.10
          </div>
          <div>
            <strong>VLANs:</strong> 11 (Server1: 172.16.11.11/24, Server2: 172.16.11.12/24)
          </div>
        </div>
      </div>
    </div>
  );
};

export default NetworkTopology3D;
