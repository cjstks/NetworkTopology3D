<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VXLAN 3D ë„¤íŠ¸ì›Œí¬ - Virtual Switch</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            font-size: 24px;
            color: white;
        }
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255,255,255,0.2);
            padding: 8px 12px;
            border-radius: 6px;
        }
        .control-group label {
            font-size: 14px;
            font-weight: 500;
            color: white;
        }
        .control-group input[type="range"] {
            width: 120px;
        }
        .control-group span {
            min-width: 40px;
            font-size: 14px;
            color: white;
        }
        button {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }
        button:hover {
            background: white;
            color: #3498db;
        }
        button.active {
            background: white;
            color: #3498db;
        }
        #canvas-container {
            width: 100%;
            height: calc(100vh - 80px);
            position: relative;
            cursor: grab;
            background: linear-gradient(to bottom, #0a0a0a 0%, #1a1a1a 100%);
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        .legend {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #3498db;
            z-index: 100;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }
        .legend h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: bold;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 12px;
            color: #fff;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
            border: 1px solid #666;
        }
        .controls-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #3498db;
            z-index: 100;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
            font-size: 12px;
            color: #fff;
        }
        .controls-info div {
            margin: 5px 0;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #3498db;
            z-index: 100;
            max-width: 350px;
            font-size: 11px;
            color: #fff;
        }
        .info-panel h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 13px;
        }
        .info-panel div {
            margin: 5px 0;
            line-height: 1.4;
        }
    </style>
</head>
<body>
<div class="header">
    <h1>ğŸŒ VXLAN Spine-Leaf with Virtual Switches</h1>
    <div class="controls">
        <div class="control-group">
            <label>ì†ë„:</label>
            <input type="range" id="speedControl" min="0" max="3" step="0.1" value="1">
            <span id="speedValue">1.0x</span>
        </div>
        <div class="control-group">
            <label>
                <input type="checkbox" id="labelToggle" checked>
                ë¼ë²¨
            </label>
        </div>
        <button id="underlayBtn" class="active">Underlay</button>
        <button id="overlayBtn" class="active">Overlay</button>
        <button id="virtualSwitchBtn" class="active">Virtual Switch</button>
        <button id="captureBtn">ğŸ“¸ ìº¡ì²˜</button>
    </div>
</div>

<div id="canvas-container">
    <div class="legend">
        <h3>ğŸ“Š ë„¤íŠ¸ì›Œí¬ ë ˆì´ì–´</h3>
        <div class="legend-item">
            <div class="legend-color" style="background: #3498db;"></div>
            <span>Underlay (ë¬¼ë¦¬ ì—°ê²°)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #e74c3c;"></div>
            <span>Overlay (VXLAN í„°ë„)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #2ecc71;"></div>
            <span>Spine ìŠ¤ìœ„ì¹˜</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #27ae60;"></div>
            <span>Leaf ìŠ¤ìœ„ì¹˜ (VTEP)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b6b;"></div>
            <span>Virtual Switch (NVE)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #95a5a6;"></div>
            <span>ì„œë²„</span>
        </div>
    </div>

    <div class="info-panel">
        <h3>ğŸ”· Underlay Network</h3>
        <div><strong>â€¢ OSPF Area 0</strong></div>
        <div><strong>â€¢ PIM Sparse-Mode</strong></div>
        <div><strong>â€¢ RP: 10.1.1.10 (Anycast)</strong></div>
        <div style="margin-top: 10px;"><strong>ì—°ê²°:</strong></div>
        <div>N9K-1 E1/1 â†” N9K-3 E1/1 (1.1.13.0/30)</div>
        <div>N9K-1 E1/2 â†” N9K-4 E1/1 (1.1.14.0/30)</div>
        <div>N9K-2 E1/1 â†” N9K-3 E1/2 (1.1.23.0/30)</div>
        <div>N9K-2 E1/2 â†” N9K-4 E1/2 (1.1.24.0/30)</div>

        <h3 style="margin-top: 15px;">ğŸ”¶ Overlay Network</h3>
        <div><strong>â€¢ VNI: 10011</strong></div>
        <div><strong>â€¢ Multicast: 225.0.0.10</strong></div>
        <div><strong>â€¢ VLAN 11 ë§¤í•‘</strong></div>
        <div style="margin-top: 10px;"><strong>Virtual Switch:</strong></div>
        <div>N9K-3 NVE1 (10.1.1.3) â†” Virtual Switch 1</div>
        <div>N9K-4 NVE1 (10.1.1.4) â†” Virtual Switch 2</div>
        <div>Virtual Switch 1 â†” Virtual Switch 2 (VXLAN)</div>
    </div>

    <div class="controls-info">
        <div><strong>ğŸ–±ï¸ ë§ˆìš°ìŠ¤ ì¡°ì‘</strong></div>
        <div>â€¢ ì¢Œí´ë¦­ + ë“œë˜ê·¸: íšŒì „</div>
        <div>â€¢ ìŠ¤í¬ë¡¤: ì¤Œ ì¸/ì•„ì›ƒ</div>
        <div>â€¢ ìš°í´ë¦­ + ë“œë˜ê·¸: ì´ë™</div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    var scene, camera, renderer;
    var devices = {};
    var underlayPackets = [];
    var overlayPackets = [];
    var underlayLines = [];
    var overlayLines = [];
    var virtualSwitchElements = [];
    var labels = [];
    var animationSpeed = 1;
    var showLabels = true;
    var showUnderlay = true;
    var showOverlay = true;
    var showVirtualSwitch = true;
    var time = 0;

    var isDragging = false;
    var previousMousePosition = { x: 0, y: 0 };
    var cameraRotation = { x: 0.4, y: 0.8 };
    var cameraDistance = 40;
    var cameraTarget = new THREE.Vector3(0, 3, 0);

    // IP Network í‰ë©´ ìœ„ì¹˜
    var ipNetworkY = 10;

    var positions = {
        // Spine ìŠ¤ìœ„ì¹˜ (ìœ„ìª½)
        N9K1: { x: -12, y: 4, z: 8 },
        N9K2: { x: 12, y: 4, z: 8 },

        // Leaf ìŠ¤ìœ„ì¹˜ (ì¤‘ê°„)
        N9K3: { x: -12, y: 0, z: -4 },
        N9K4: { x: 12, y: 0, z: -4 },

        // Virtual Switches (IP Network í‰ë©´ ìœ„)
        VirtualSwitch1: { x: -12, y: ipNetworkY, z: -4 },
        VirtualSwitch2: { x: 12, y: ipNetworkY, z: -4 },

        // ì„œë²„ (ì•„ë˜ìª½)
        Server1: { x: -12, y: 0, z: -14 },
        Server2: { x: 12, y: 0, z: -14 }
    };

    function init() {
        var container = document.getElementById('canvas-container');

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 50, 100);

        camera = new THREE.PerspectiveCamera(
            60,
            container.clientWidth / container.clientHeight,
            0.1,
            1000
        );
        updateCameraPosition();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        var ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(20, 30, 20);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        var fillLight = new THREE.DirectionalLight(0x3498db, 0.3);
        fillLight.position.set(-20, 20, -20);
        scene.add(fillLight);

        var gridHelper = new THREE.GridHelper(60, 60, 0x333333, 0x222222);
        gridHelper.position.y = -2;
        scene.add(gridHelper);

        // IP Network í‰ë©´ ìƒì„±
        createIPNetworkPlane();

        // ì¥ë¹„ ìƒì„±
        createRouter('N9K1', positions.N9K1, 0x2ecc71, 'Spine');
        createRouter('N9K2', positions.N9K2, 0x2ecc71, 'Spine');
        createRouter('N9K3', positions.N9K3, 0x27ae60, 'Leaf-VTEP');
        createRouter('N9K4', positions.N9K4, 0x27ae60, 'Leaf-VTEP');
        createVirtualSwitch('VirtualSwitch1', positions.VirtualSwitch1);
        createVirtualSwitch('VirtualSwitch2', positions.VirtualSwitch2);
        createServer('Server1', positions.Server1, 0x95a5a6);
        createServer('Server2', positions.Server2, 0x7f8c8d);

        // Underlay ì—°ê²°
        createUnderlayConnection('N9K1', 'N9K3', 0);
        createUnderlayConnection('N9K1', 'N9K4', 1);
        createUnderlayConnection('N9K2', 'N9K3', 2);
        createUnderlayConnection('N9K2', 'N9K4', 3);

        // Overlay ì—°ê²° (Virtual Switchë¥¼ í†µí•´)
        createOverlayConnection('VirtualSwitch1', 'VirtualSwitch2', 0);

        // VTEPì™€ Virtual Switch ë¡œì»¬ ì—°ê²°
        createLocalConnection('N9K3', 'VirtualSwitch1', 'vtep');
        createLocalConnection('N9K4', 'VirtualSwitch2', 'vtep');

        // Virtual Switchì™€ Server ì—°ê²°
        createLocalConnection('VirtualSwitch1', 'Server1', 'access');
        createLocalConnection('VirtualSwitch2', 'Server2', 'access');

        // ë¼ë²¨ ìƒì„±
        var posKeys = Object.keys(positions);
        for (var k = 0; k < posKeys.length; k++) {
            if (!posKeys[k].includes('VirtualSwitch')) {
                createLabel(posKeys[k], positions[posKeys[k]]);
            }
        }

        window.addEventListener('resize', onWindowResize);

        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('wheel', onMouseWheel);
        renderer.domElement.addEventListener('contextmenu', function(e) { e.preventDefault(); });

        document.getElementById('speedControl').addEventListener('input', function(e) {
            animationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
        });

        document.getElementById('labelToggle').addEventListener('change', function(e) {
            showLabels = e.target.checked;
        });

        document.getElementById('underlayBtn').addEventListener('click', function() {
            showUnderlay = !showUnderlay;
            this.classList.toggle('active');
        });

        document.getElementById('overlayBtn').addEventListener('click', function() {
            showOverlay = !showOverlay;
            this.classList.toggle('active');
        });

        document.getElementById('virtualSwitchBtn').addEventListener('click', function() {
            showVirtualSwitch = !showVirtualSwitch;
            this.classList.toggle('active');
        });

        document.getElementById('captureBtn').addEventListener('click', captureFrame);

        animate();
    }

    function createIPNetworkPlane() {
        // í° ë°˜íˆ¬ëª… í‰ë©´
        var planeGeo = new THREE.CircleGeometry(18, 64);
        var planeMat = new THREE.MeshPhongMaterial({
            color: 0x3498db,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide,
            emissive: 0x3498db,
            emissiveIntensity: 0.1
        });
        var plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.set(0, ipNetworkY, -4);
        scene.add(plane);
        virtualSwitchElements.push(plane);

        // í…Œë‘ë¦¬ ë§
        var ringGeo = new THREE.RingGeometry(17.5, 18, 64);
        var ringMat = new THREE.MeshBasicMaterial({
            color: 0x3498db,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
        });
        var ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = -Math.PI / 2;
        ring.position.set(0, ipNetworkY + 0.01, -4);
        scene.add(ring);
        virtualSwitchElements.push(ring);

        // "IP Network" í…ìŠ¤íŠ¸
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 128;

        ctx.fillStyle = 'rgba(52, 152, 219, 0.3)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = 'bold 56px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('IP Network', 256, 80);

        var texture = new THREE.CanvasTexture(canvas);
        var spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        var sprite = new THREE.Sprite(spriteMat);
        sprite.position.set(0, ipNetworkY + 0.5, -4);
        sprite.scale.set(12, 3, 1);
        scene.add(sprite);
        virtualSwitchElements.push(sprite);
    }

    function createVirtualSwitch(name, position) {
        var group = new THREE.Group();

        // ë©”ì¸ ë°”ë””
        var bodyGeo = new THREE.BoxGeometry(3.5, 1.2, 3.5);
        var bodyMat = new THREE.MeshPhongMaterial({
            color: 0xff6b6b,
            transparent: true,
            opacity: 0.7,
            specular: 0x888888,
            shininess: 60,
            emissive: 0xff6b6b,
            emissiveIntensity: 0.4
        });
        var body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);

        // ì™€ì´ì–´í”„ë ˆì„
        var wireframeGeo = new THREE.EdgesGeometry(bodyGeo);
        var wireframeMat = new THREE.LineBasicMaterial({
            color: 0xff3333,
            linewidth: 3,
            transparent: true,
            opacity: 0.9
        });
        var wireframe = new THREE.LineSegments(wireframeGeo, wireframeMat);
        group.add(wireframe);

        // ê¸€ë¡œìš° íš¨ê³¼
        var glowGeo = new THREE.BoxGeometry(4, 1.7, 4);
        var glowMat = new THREE.MeshBasicMaterial({
            color: 0xff6b6b,
            transparent: true,
            opacity: 0.2,
            side: THREE.BackSide
        });
        var glow = new THREE.Mesh(glowGeo, glowMat);
        group.add(glow);
        group.userData.glow = glow;

        // í¬íŠ¸ í‘œì‹œ
        for (var i = 0; i < 4; i++) {
            var angle = (i / 4) * Math.PI * 2;
            var radius = 2;
            var portGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.4);
            var portMat = new THREE.MeshPhongMaterial({
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.8
            });
            var port = new THREE.Mesh(portGeo, portMat);
            port.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            );
            port.rotation.z = Math.PI / 2;
            group.add(port);
        }

        // ë¼ë²¨
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 128;

        ctx.fillStyle = 'rgba(255, 107, 107, 0.9)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'white';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Virtual', 128, 50);
        ctx.fillText('Switch', 128, 90);

        var texture = new THREE.CanvasTexture(canvas);
        var labelMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        var label = new THREE.Sprite(labelMat);
        label.position.set(0, 0, 1.8);
        label.scale.set(3.5, 1.75, 1);
        group.add(label);

        group.position.set(position.x, position.y, position.z);
        scene.add(group);
        devices[name] = group;
        virtualSwitchElements.push(group);
    }

    function createRouter(name, position, color, type) {
        var group = new THREE.Group();

        var geometry = new THREE.BoxGeometry(2.5, 3, 2.5);
        var material = new THREE.MeshPhongMaterial({
            color: color,
            specular: 0x666666,
            shininess: 40
        });
        var mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        group.add(mesh);

        var edgesGeo = new THREE.EdgesGeometry(geometry);
        var edgesMat = new THREE.LineBasicMaterial({ color: 0x1a1a1a, linewidth: 2 });
        var edges = new THREE.LineSegments(edgesGeo, edgesMat);
        group.add(edges);

        // íŒ¨ë„
        for (var i = 0; i < 6; i++) {
            var panelGeo = new THREE.BoxGeometry(2.6, 0.35, 0.1);
            var panelMat = new THREE.MeshPhongMaterial({ color: 0x2c3e50 });
            var panel = new THREE.Mesh(panelGeo, panelMat);
            panel.position.set(0, -1.3 + i * 0.5, 1.26);
            group.add(panel);

            for (var j = 0; j < 4; j++) {
                var portGeo = new THREE.BoxGeometry(0.15, 0.15, 0.05);
                var portMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
                var port = new THREE.Mesh(portGeo, portMat);
                port.position.set(-0.9 + j * 0.6, -1.3 + i * 0.5, 1.32);
                group.add(port);
            }
        }

        // LED
        var leds = [];
        for (var i = 0; i < 10; i++) {
            var ledGeo = new THREE.SphereGeometry(0.08);
            var ledMat = new THREE.MeshPhongMaterial({
                color: 0x2ecc71,
                emissive: 0x2ecc71,
                emissiveIntensity: 0.5
            });
            var led = new THREE.Mesh(ledGeo, ledMat);
            led.position.set(-1 + i * 0.22, 1.3, 1.27);
            led.userData = { ledIndex: i, material: ledMat };
            group.add(led);
            leds.push(led);
        }
        group.userData.leds = leds;

        // VTEP ë¼ë²¨
        if (type === 'Leaf-VTEP') {
            var vtepGeo = new THREE.BoxGeometry(2, 0.4, 0.15);
            var vtepMat = new THREE.MeshPhongMaterial({
                color: 0xe74c3c,
                emissive: 0xe74c3c,
                emissiveIntensity: 0.3
            });
            var vtep = new THREE.Mesh(vtepGeo, vtepMat);
            vtep.position.set(0, -1.7, 1.28);
            group.add(vtep);
        }

        group.position.set(position.x, position.y, position.z);
        scene.add(group);
        devices[name] = group;
    }

    function createServer(name, position, color) {
        var group = new THREE.Group();

        var geometry = new THREE.BoxGeometry(1.8, 2.5, 1.8);
        var material = new THREE.MeshPhongMaterial({
            color: color,
            specular: 0x555555,
            shininess: 30
        });
        var mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        group.add(mesh);

        var edgesGeo = new THREE.EdgesGeometry(geometry);
        var edgesMat = new THREE.LineBasicMaterial({ color: 0x1a1a1a, linewidth: 2 });
        var edges = new THREE.LineSegments(edgesGeo, edgesMat);
        group.add(edges);

        var screenGeo = new THREE.PlaneGeometry(1.3, 1.3);
        var screenMat = new THREE.MeshPhongMaterial({
            color: 0x2c3e50,
            emissive: 0x3498db,
            emissiveIntensity: 0.3
        });
        var screen = new THREE.Mesh(screenGeo, screenMat);
        screen.position.set(0, 0.2, 0.91);
        group.add(screen);

        var bezelGeo = new THREE.PlaneGeometry(1.5, 1.5);
        var bezelMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
        var bezel = new THREE.Mesh(bezelGeo, bezelMat);
        bezel.position.set(0, 0.2, 0.9);
        group.add(bezel);

        group.position.set(position.x, position.y, position.z);
        scene.add(group);
        devices[name] = group;
    }

    function createUnderlayConnection(fromName, toName, index) {
        var fromPos = positions[fromName];
        var toPos = positions[toName];

        var curve = new THREE.LineCurve3(
            new THREE.Vector3(fromPos.x, fromPos.y, fromPos.z),
            new THREE.Vector3(toPos.x, toPos.y, toPos.z)
        );

        var points = curve.getPoints(50);
        var geometry = new THREE.BufferGeometry().setFromPoints(points);
        var material = new THREE.LineBasicMaterial({
            color: 0x3498db,
            linewidth: 3,
            transparent: true,
            opacity: 0.8
        });

        var line = new THREE.Line(geometry, material);
        scene.add(line);
        underlayLines.push(line);

        var tubeGeo = new THREE.TubeGeometry(curve, 20, 0.08, 8, false);
        var tubeMat = new THREE.MeshPhongMaterial({
            color: 0x3498db,
            transparent: true,
            opacity: 0.6,
            emissive: 0x3498db,
            emissiveIntensity: 0.3
        });
        var tube = new THREE.Mesh(tubeGeo, tubeMat);
        scene.add(tube);
        underlayLines.push(tube);

        for (var i = 0; i < 3; i++) {
            var packetGeo = new THREE.SphereGeometry(0.15);
            var packetMat = new THREE.MeshPhongMaterial({
                color: 0x3498db,
                transparent: true,
                opacity: 0.9,
                emissive: 0x3498db,
                emissiveIntensity: 0.5
            });
            var packet = new THREE.Mesh(packetGeo, packetMat);

            packet.userData = {
                curve: curve,
                progress: i * 0.33,
                speed: 0.3,
                index: index
            };
            scene.add(packet);
            underlayPackets.push(packet);
        }
    }

    function createOverlayConnection(fromName, toName, index) {
        var fromPos = positions[fromName];
        var toPos = positions[toName];

        var midY = ipNetworkY + 4;

        var curve = new THREE.QuadraticBezierCurve3(
            new THREE.Vector3(fromPos.x, fromPos.y, fromPos.z),
            new THREE.Vector3((fromPos.x + toPos.x) / 2, midY, (fromPos.z + toPos.z) / 2),
            new THREE.Vector3(toPos.x, toPos.y, toPos.z)
        );

        var points = curve.getPoints(50);
        var geometry = new THREE.BufferGeometry().setFromPoints(points);
        var material = new THREE.LineBasicMaterial({
            color: 0xe74c3c,
            linewidth: 4,
            transparent: true,
            opacity: 0.8
        });

        var line = new THREE.Line(geometry, material);
        scene.add(line);
        overlayLines.push(line);

        var tubeGeo = new THREE.TubeGeometry(curve, 50, 0.15, 8, false);
        var tubeMat = new THREE.MeshPhongMaterial({
            color: 0xe74c3c,
            transparent: true,
            opacity: 0.6,
            emissive: 0xe74c3c,
            emissiveIntensity: 0.4
        });
        var tube = new THREE.Mesh(tubeGeo, tubeMat);
        scene.add(tube);
        overlayLines.push(tube);

        for (var i = 0; i < 3; i++) {
            var packetGeo = new THREE.SphereGeometry(0.3);
            var packetMat = new THREE.MeshPhongMaterial({
                color: 0xf39c12,
                transparent: true,
                opacity: 0.9,
                emissive: 0xf39c12,
                emissiveIntensity: 0.6
            });
            var packet = new THREE.Mesh(packetGeo, packetMat);

            packet.userData = {
                curve: curve,
                progress: i / 3,
                speed: 0.15,
                index: index
            };
            scene.add(packet);
            overlayPackets.push(packet);
        }
    }

    function createLocalConnection(fromName, toName, type) {
        var fromPos = positions[fromName];
        var toPos = positions[toName];

        var curve = new THREE.LineCurve3(
            new THREE.Vector3(fromPos.x, fromPos.y, fromPos.z),
            new THREE.Vector3(toPos.x, toPos.y, toPos.z)
        );

        var points = curve.getPoints(20);
        var geometry = new THREE.BufferGeometry().setFromPoints(points);

        var lineColor = type === 'vtep' ? 0xff6b6b : 0x95a5a6;
        var material = new THREE.LineDashedMaterial({
            color: lineColor,
            linewidth: 2,
            dashSize: 0.3,
            gapSize: 0.2,
            transparent: true,
            opacity: 0.7
        });

        var line = new THREE.Line(geometry, material);
        line.computeLineDistances();
        scene.add(line);

        if (type === 'vtep' || type === 'access') {
            virtualSwitchElements.push(line);
        }

        var tubeRadius = type === 'vtep' ? 0.08 : 0.05;
        var tubeGeo = new THREE.TubeGeometry(curve, 20, tubeRadius, 8, false);
        var tubeMat = new THREE.MeshPhongMaterial({
            color: lineColor,
            transparent: true,
            opacity: type === 'vtep' ? 0.5 : 0.3,
            emissive: lineColor,
            emissiveIntensity: type === 'vtep' ? 0.3 : 0.1
        });
        var tube = new THREE.Mesh(tubeGeo, tubeMat);
        scene.add(tube);

        if (type === 'vtep' || type === 'access') {
            virtualSwitchElements.push(tube);
        }
    }

    function createLabel(text, position) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 80;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = '#3498db';
        ctx.lineWidth = 4;
        ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(text, 128, 50);

        var texture = new THREE.CanvasTexture(canvas);
        var material = new THREE.SpriteMaterial({ map: texture });
        var sprite = new THREE.Sprite(material);
        sprite.position.set(position.x, position.y + 3, position.z);
        sprite.scale.set(4, 1, 1);
        scene.add(sprite);
        labels.push(sprite);
    }

    function onMouseDown(e) {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseMove(e) {
        if (!isDragging) return;

        var deltaX = e.clientX - previousMousePosition.x;
        var deltaY = e.clientY - previousMousePosition.y;

        if (e.buttons === 1) {
            cameraRotation.y += deltaX * 0.005;
            cameraRotation.x += deltaY * 0.005;
            cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
        } else if (e.buttons === 2) {
            var right = new THREE.Vector3();
            var up = new THREE.Vector3(0, 1, 0);
            camera.getWorldDirection(right);
            right.cross(up).normalize();

            cameraTarget.add(right.multiplyScalar(-deltaX * 0.02));
            cameraTarget.y -= deltaY * 0.02;
        }

        updateCameraPosition();
        previousMousePosition = { x: e.clientX, y: e.clientY };
    }

    function onMouseUp() {
        isDragging = false;
    }

    function onMouseWheel(e) {
        e.preventDefault();
        cameraDistance += e.deltaY * 0.02;
        cameraDistance = Math.max(15, Math.min(80, cameraDistance));
        updateCameraPosition();
    }

    function updateCameraPosition() {
        var x = cameraDistance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
        var y = cameraDistance * Math.sin(cameraRotation.x);
        var z = cameraDistance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);

        camera.position.set(
            cameraTarget.x + x,
            cameraTarget.y + y,
            cameraTarget.z + z
        );
        camera.lookAt(cameraTarget);
    }

    function animate() {
        requestAnimationFrame(animate);
        time += 0.016 * animationSpeed;

        // ì¥ë¹„ LED ì• ë‹ˆë©”ì´ì…˜
        var deviceKeys = Object.keys(devices);
        for (var i = 0; i < deviceKeys.length; i++) {
            var device = devices[deviceKeys[i]];

            if (device.userData.leds) {
                var leds = device.userData.leds;
                for (var j = 0; j < leds.length; j++) {
                    var led = leds[j];
                    var brightness = Math.sin(time * 5 + led.userData.ledIndex * 0.6) * 0.3 + 0.7;
                    led.userData.material.emissiveIntensity = brightness;
                }
            }

            if (device.userData.glow) {
                var glowScale = 1 + Math.sin(time * 2) * 0.1;
                device.userData.glow.scale.set(glowScale, glowScale, glowScale);
                device.userData.glow.material.opacity = 0.15 + Math.sin(time * 2) * 0.05;
            }

            if (deviceKeys[i].includes('VirtualSwitch')) {
                device.rotation.y = time * 0.2;
            }
        }

        // Underlay íŒ¨í‚· ì• ë‹ˆë©”ì´ì…˜
        for (var i = 0; i < underlayPackets.length; i++) {
            var packet = underlayPackets[i];
            packet.userData.progress += 0.01 * packet.userData.speed * animationSpeed;
            if (packet.userData.progress > 1) {
                packet.userData.progress = 0;
            }

            var point = packet.userData.curve.getPoint(packet.userData.progress);
            packet.position.copy(point);
            packet.visible = showUnderlay;
        }

        // Overlay íŒ¨í‚· ì• ë‹ˆë©”ì´ì…˜
        for (var i = 0; i < overlayPackets.length; i++) {
            var packet = overlayPackets[i];
            packet.userData.progress += 0.008 * packet.userData.speed * animationSpeed;
            if (packet.userData.progress > 1) {
                packet.userData.progress = 0;
            }

            var point = packet.userData.curve.getPoint(packet.userData.progress);
            packet.position.copy(point);

            var scale = 1 + Math.sin(time * 4 + packet.userData.index) * 0.2;
            packet.scale.set(scale, scale, scale);
            packet.visible = showOverlay;
        }

        // Underlay ë¼ì¸ í‘œì‹œ
        for (var i = 0; i < underlayLines.length; i++) {
            underlayLines[i].visible = showUnderlay;
        }

        // Overlay ë¼ì¸ í‘œì‹œ
        for (var i = 0; i < overlayLines.length; i++) {
            overlayLines[i].visible = showOverlay;
        }

        // Virtual Switch ìš”ì†Œ í‘œì‹œ
        for (var i = 0; i < virtualSwitchElements.length; i++) {
            virtualSwitchElements[i].visible = showVirtualSwitch;
        }

        // ë¼ë²¨ í‘œì‹œ
        for (var i = 0; i < labels.length; i++) {
            labels[i].visible = showLabels;
        }

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        var container = document.getElementById('canvas-container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function captureFrame() {
        var dataUrl = renderer.domElement.toDataURL('image/png');
        var link = document.createElement('a');
        link.download = 'vxlan-virtual-switch-' + Date.now() + '.png';
        link.href = dataUrl;
        link.click();
    }

    init();
</script>
</body>
</html>
